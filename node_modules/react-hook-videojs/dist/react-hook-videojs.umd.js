(function(global, factory) {
  typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require("react"), require("video.js"), require("lodash.clonedeep"), require("dequal")) : typeof define === "function" && define.amd ? define(["exports", "react", "video.js", "lodash.clonedeep", "dequal"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global["react-hook-videojs"] = {}, global.react, global.video.js, global.lodash.clonedeep, global.dequal));
})(this, function(exports2, React, videojs, cloneDeep, dequal) {
  "use strict";
  const _interopDefaultLegacy = (e) => e && typeof e === "object" && "default" in e ? e : { default: e };
  const React__default = /* @__PURE__ */ _interopDefaultLegacy(React);
  const videojs__default = /* @__PURE__ */ _interopDefaultLegacy(videojs);
  const cloneDeep__default = /* @__PURE__ */ _interopDefaultLegacy(cloneDeep);
  function useDeepCompareMemoize(value) {
    const ref = React__default.default.useRef(value);
    const signalRef = React__default.default.useRef(0);
    if (!dequal.dequal(value, ref.current)) {
      ref.current = value;
      signalRef.current += 1;
    }
    return React__default.default.useMemo(() => ref.current, [signalRef.current]);
  }
  const VideoJsWrapper = React.forwardRef(({ children, videoJsOptions, onReady, onDispose, classNames, ...props }, playerRef) => {
    const player = playerRef;
    const videoJsOptionsCloned = cloneDeep__default.default(videoJsOptions);
    const videoNode = React.useRef(null);
    const containerRef = React.useRef(null);
    React.useLayoutEffect(() => {
      var _a;
      if (!((_a = videoNode.current) == null ? void 0 : _a.parentNode))
        return;
      const originalVideoNodeParent = videoNode.current.parentNode.cloneNode(true);
      if (!player.current) {
        player.current = videojs__default.default(videoNode.current, videoJsOptionsCloned);
        player.current.ready(() => {
          onReady();
        });
      }
      return () => {
        var _a2;
        if (player.current) {
          player.current.dispose();
          if (containerRef.current && ((_a2 = videoNode.current) == null ? void 0 : _a2.parentNode) && !containerRef.current.contains(videoNode.current.parentNode)) {
            containerRef.current.appendChild(originalVideoNodeParent);
            videoNode.current = originalVideoNodeParent.firstChild;
          }
          player.current = null;
          onDispose();
        }
      };
    }, [useDeepCompareMemoize(videoJsOptions)]);
    return /* @__PURE__ */ React__default.default.createElement("div", {
      ref: containerRef
    }, /* @__PURE__ */ React__default.default.createElement("div", {
      "data-vjs-player": true
    }, /* @__PURE__ */ React__default.default.createElement("video", {
      ref: videoNode,
      className: `video-js ${classNames}`,
      ...props
    }, children)));
  });
  VideoJsWrapper.displayName = "VideoJsWrapper";
  const useVideoJS = (videoJsOptions, classNames = "") => {
    const [ready, setReady] = React.useState(false);
    const player = React.useRef(null);
    const Video = React.useCallback(({ children, ...props }) => /* @__PURE__ */ React__default.default.createElement(VideoJsWrapper, {
      videoJsOptions,
      classNames,
      onReady: () => setReady(true),
      onDispose: () => setReady(false),
      ...props,
      ref: player
    }, children), [useDeepCompareMemoize(videoJsOptions), classNames]);
    return { Video, ready, player: player.current };
  };
  exports2.useVideoJS = useVideoJS;
  Object.defineProperties(exports2, { __esModule: { value: true }, [Symbol.toStringTag]: { value: "Module" } });
});
//# sourceMappingURL=react-hook-videojs.umd.js.map
